<html><head>
<title>BatchG</title>
</head><body>

<h1>BatchG</h1>

<center>[ <a target="showcase" href="/Demo/BatchG/main">Application</a> | <a target="showcase" href="batchG.urp.html"><tt>batchG.urp</tt></a> | <a target="showcase" href="batchFun.urs.html"><tt>batchFun.urs</tt></a> | <a target="showcase" href="batchFun.ur.html"><tt>batchFun.ur</tt></a> | <a target="showcase" href="batchG.urs.html"><tt>batchG.urs</tt></a> | <a target="showcase" href="batchG.ur.html"><tt>batchG.ur</tt></a> ]</center>


<p>We can redo the last example with a generic component, like we did in the <tt>Crud</tt> examples.  The module <tt>BatchFun</tt> is analogous to the <tt>Crud</tt> module.  It contains a functor that builds a batching editor, when given a suitable description of a table.</p>

<p>The signature of the functor is the same as for <tt>Crud</tt>.  We change the definition of <tt>colMeta</tt> to reflect the different kinds of column metadata that we need.  Each column is still described by a pair of types, and the first element of each pair still gives the SQL type for a column.  Now, however, the second type in a pair gives a type of <i>local state</i> to be used in a reactive widget for inputing that column.</p>

<p>The first three fields of a <tt>colMeta</tt> record are the same as for <tt>Crud</tt>.  The rest of the fields are:</p>
<ol>
        <li><tt>NewState</tt>, which allocates some new widget local state</li>
        <li><tt>Widget</tt>, which produces a reactive widget from some state</li>
        <li><tt>ReadState</tt>, which reads the current value of some state to determine which SQL value it encodes</li>
</ol>

<p><tt>BatchFun.Make</tt> handles the plumbing of allocating the local state, using it to create widgets, and reading the state values when the user clicks "Batch it."</p>

<p><tt>batchG.ur</tt> contains an example instantiation, which is just as easy to write as in the <tt>Crud1</tt> example.</p>


</body></html>
