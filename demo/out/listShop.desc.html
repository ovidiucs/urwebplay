<html><head>
<title>ListShop</title>
</head><body>

<h1>ListShop</h1>

<center>[ <a target="showcase" href="/Demo/ListShop/main">Application</a> | <a target="showcase" href="listShop.urp.html"><tt>listShop.urp</tt></a> | <a target="showcase" href="list.urs.html"><tt>list.urs</tt></a> | <a target="showcase" href="list.ur.html"><tt>list.ur</tt></a> | <a target="showcase" href="listFun.urs.html"><tt>listFun.urs</tt></a> | <a target="showcase" href="listFun.ur.html"><tt>listFun.ur</tt></a> | <a target="showcase" href="listShop.urs.html"><tt>listShop.urs</tt></a> | <a target="showcase" href="listShop.ur.html"><tt>listShop.ur</tt></a> ]</center>


<p>This example shows off algebraic datatypes, parametric polymorphism, and functors.</p>

<p>The <tt>List</tt> module defines a list datatype, much in the style of SML, but with type parameters written more in Haskell style.  The types of <tt>List.length</tt> and <tt>List.rev</tt> indicate that they are polymorphic.  Types like <tt>t ::: Type -> ...</tt> indicate polymorphism, with the triple colon denoting that the value of this type parameter should be <i>inferred</i> at uses.  A double colon would mean that the type argument must be provided explicitly at uses.  In contrast to ML and Haskell, all polymorphism must be <i>declared</i> explicitly in Ur, while instantiations may be inferred at uses.</p>

<p>The <tt>ListFun</tt> module defines a functor for building list editing sub-applications.  An argument to the functor <tt>Make</tt> must give the type to be stored in the lists, along with marshaling and unmarshaling functions.  In return, the functor returns an entry point function.</p>

<p>The <tt>ListShop</tt> modules ties everything together by instantiating <tt>ListFun.Make</tt> with structures for integers and strings.  <tt>show</tt> and <tt>read</tt> can be used for marshaling and unmarshaling in both cases because they are type-class-generic.</p>


</body></html>
