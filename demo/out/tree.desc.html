<html><head>
<title>Tree</title>
</head><body>

<h1>Tree</h1>

<center>[ <a target="showcase" href="/Demo/Tree/main">Application</a> | <a target="showcase" href="tree.urp.html"><tt>tree.urp</tt></a> | <a target="showcase" href="treeFun.urs.html"><tt>treeFun.urs</tt></a> | <a target="showcase" href="treeFun.ur.html"><tt>treeFun.ur</tt></a> | <a target="showcase" href="tree.urs.html"><tt>tree.urs</tt></a> | <a target="showcase" href="tree.ur.html"><tt>tree.ur</tt></a> ]</center>


<p>Here we see how we can abstract over common patterns of SQL queries.  In particular, since standard SQL does not help much with queries over trees, we write a function for traversing an SQL tree, building an HTML representation, based on a user-provided function for rendering individual rows.</p>

<p>The signature of <tt>TreeFun.Make</tt> tells us that, to instantiate the functor, we must provide</p>
<ol>
        <li>A primary key type <tt>key</tt></li>
        <li>SQL field names <tt>id</tt> (for primary keys) and <tt>parent</tt> (for parent links)</li>
        <li>A type-level record <tt>cols</tt> of field names besides <tt>id</tt> and <tt>parent</tt></li>
        <li>"Proofs" that <tt>id</tt> is distinct from <tt>parent</tt> and that neither of <tt>id</tt> and <tt>parent</tt> appears in <tt>cols</tt></li>
        <li>A witness that <tt>key</tt> belongs to the type class <tt>sql_injectable_prim</tt>, which indicates that both <tt>key</tt> and <tt>option key</tt> are fair game to use with SQL</li>
        <li>An SQL table <tt>tab</tt>, containing a field <tt>id</tt> of type <tt>key</tt>, a field <tt>parent</tt> of type <tt>option key</tt>, and every field of <tt>cols</tt></li>
</ol>


</body></html>
