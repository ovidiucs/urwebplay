<html><head>
<title>Chat</title>
</head><body>

<h1>Chat</h1>

<center>[ <a target="showcase" href="/Demo/Chat/main">Application</a> | <a target="showcase" href="chat.urp.html"><tt>chat.urp</tt></a> | <a target="showcase" href="broadcast.urs.html"><tt>broadcast.urs</tt></a> | <a target="showcase" href="broadcast.ur.html"><tt>broadcast.ur</tt></a> | <a target="showcase" href="buffer.urs.html"><tt>buffer.urs</tt></a> | <a target="showcase" href="buffer.ur.html"><tt>buffer.ur</tt></a> | <a target="showcase" href="chat.urs.html"><tt>chat.urs</tt></a> | <a target="showcase" href="chat.ur.html"><tt>chat.ur</tt></a> ]</center>


<p>This example provides a simple anonymous online chatting system, with multiple named channels.</p>

<p>First, we build another useful component.  Recall that each channel has an owning client, who has the exclusive ability to read messages sent to it.  On top of that functionality, we can build a kind of broadcast channel that accepts multiple subscribers.  The <tt>Broadcast</tt> module contains a functor with such an implementation.  We instantiate the functor with the type of data we want to send over the channel.  The functor output gives us an abstract type of "topics," which are subscribable IDs.  When a client subscribes to a topic, it is handed a channel that it can use to read new messages on that topic.  We also have an operation to count the number of subscribers to a topic.  This number shouldn't be treated as too precise, since some clients that have surfed away from the application may still be considered subscribed until a timeout period elapses.</p>

<p>The main <tt>Chat</tt> application includes some standard management of a table of named channels.  All of the interesting client-server work is done with the <tt>recv</tt> function and with the functions provided by <tt>Broadcast</tt>.</p>

</body></html>
